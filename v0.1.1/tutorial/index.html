<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ConceptualClimateModels.jl</title><meta name="title" content="Tutorial · ConceptualClimateModels.jl"/><meta property="og:title" content="Tutorial · ConceptualClimateModels.jl"/><meta property="twitter:title" content="Tutorial · ConceptualClimateModels.jl"/><meta name="description" content="Documentation for ConceptualClimateModels.jl."/><meta property="og:description" content="Documentation for ConceptualClimateModels.jl."/><meta property="twitter:description" content="Documentation for ConceptualClimateModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ConceptualClimateModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Introductory-example"><span>Introductory example</span></a></li><li><a class="tocitem" href="#Processes"><span>Processes</span></a></li><li><a class="tocitem" href="#Default-processes"><span>Default processes</span></a></li><li><a class="tocitem" href="#Adding-your-own-processes"><span>Adding your own processes</span></a></li><li><a class="tocitem" href="#global_vars"><span>Premade symbolic variable instances</span></a></li><li><a class="tocitem" href="#Automatically-named-parameters"><span>Automatically named parameters</span></a></li><li><a class="tocitem" href="#Integration-with-DynamicalSystems.jl"><span>Integration with DynamicalSystems.jl</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li><li><a class="tocitem" href="../processes/">Predefined processes</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/ConceptualClimateModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/ConceptualClimateModels.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial"><a class="docs-heading-anchor" href="#tutorial">Tutorial</a><a id="tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial" title="Permalink"></a></h1><p>With ConceptualClimateModels.jl one makes differential equation systems from <em>processes</em>. A <em>process</em> is simply a particular equation defining the dynamics of a climate variable. A vector of processes is composed by the user, and given to the main function <a href="#ConceptualClimateModels.processes_to_coupledodes"><code>processes_to_coupledodes</code></a> which bundles them into a system of equations that creates a dynamical system.</p><div class="admonition is-info"><header class="admonition-header">Familiarity with DynamicalSystems.jl and ModelingToolkit.jl</header><div class="admonition-body"><p>ConceptualClimateModels.jl builds on <a href="https://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit.jl</a> for building the equations representing the climate model, and it builds on <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/dev/">DynamicalSystems.jl</a> to analyze the models. Familiarity with either package is good to have, and will allow you to faster and better understand the concepts discussed here. Nevertheless familiarity is actually optional as the steps required to use ConceptualClimateModels.jl are all explained in this tutorial.</p></div></div><h2 id="Introductory-example"><a class="docs-heading-anchor" href="#Introductory-example">Introductory example</a><a id="Introductory-example-1"></a><a class="docs-heading-anchor-permalink" href="#Introductory-example" title="Permalink"></a></h2><p>Let&#39;s say that we want to create the most basic energy balance model,</p><p class="math-container">\[c_T \frac{dT}{dt} = ASR - OLR + f\]</p><p>where <span>$ASR$</span> is the absorbed solar radiation given by</p><p class="math-container">\[ASR = S (1-\alpha)\]</p><p>with <span>$\alpha$</span> the planetary albedo, <span>$OLR$</span> is the outgoing longwave radiation given by the linearized expression</p><p class="math-container">\[OLR = A + BT\]</p><p>and <span>$f$</span> some radiative forcing at the top of the atmosphere, that is based on CO2 concentrations and given by</p><p class="math-container">\[f = 3.7\log_2\left(\frac{CO_2}{400}\right)\]</p><p>with CO2 concentrations in ppm.</p><p>To create this model with ConceptualClimateModels.jl while providing the least information possible we can do:</p><pre><code class="language-julia hljs">using ConceptualClimateModels
using ConceptualClimateModels.CCMV

processes = [
    BasicRadiationBalance(),
    LinearOLR(),
    ParameterProcess(α),
    CO2Forcing(), # note that for default CO2 value this is zero forcing
]

ds = processes_to_coupledodes(processes)
println(dynamical_system_summary(ds))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-dimensional CoupledODEs
 deterministic: true
 discrete time: false
 in-place:      false

with equations:
 Differential(t)(T(t)) ~ (-0.0029390154298310064(ASR(t) + f(t) - OLR(t))) / (-τ_T)
 OLR(t) ~ -277.0 + 1.8T(t)
 CO2(t) ~ CO2_0
 S(t) ~ 1.0
 α(t) ~ α_0
 f(t) ~ 3.7log2((1//400)*CO2(t))
 ASR(t) ~ 340.25S(t)*(1 - α(t))

and parameter values:
 τ_T ~ 1.4695077149155033e6
 α_0 ~ 0.3
 CO2_0 ~ 400.0</code></pre><p>The output is a dynamical system from <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/stable/">DynamicalSystems.jl</a> that is generated via symbolic expressions based on <a href="https://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit.jl</a>, utilizing the process-based approach of <a href="https://juliadynamics.github.io/ProcessBasedModelling.jl/stable/">ProcessBasedModelling.jl</a>.</p><p>As the dynamical system is made by symbolic expressions, these can be obtained back at any time:</p><pre><code class="language-julia hljs">using DynamicalSystems
# access the MTK model that stores the symbolic bindings
mtk = referrenced_sciml_model(ds)
# show the equations of the dynamic state variables of the dynamical system
equations(mtk)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} T\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - 0.002939 \left( \mathrm{ASR}\left( t \right) + f\left( t \right) - \mathrm{OLR}\left( t \right) \right)}{ - \tau_{T}}
\end{align}
 \]</p><pre><code class="language-julia hljs"># show state functions that are observable,
# i.e., they do not have a time derivative, they are not dynamic state variables
observed(mtk)</code></pre><p class="math-container">\[ \begin{align}
\mathrm{OLR}\left( t \right) =&amp; -277 + 1.8 T\left( t \right) \\
\mathrm{CO2}\left( t \right) =&amp; CO2_{0} \\
S\left( t \right) =&amp; 1 \\
\alpha\left( t \right) =&amp; \alpha_{0} \\
f\left( t \right) =&amp; 3.7 \log_{2}\left( \frac{1}{400} \mathrm{CO2}\left( t \right) \right) \\
\mathrm{ASR}\left( t \right) =&amp; 340.25 S\left( t \right) \left( 1 - \alpha\left( t \right) \right)
\end{align}
 \]</p><pre><code class="language-julia hljs"># show parameters
parameters(mtk)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 τ_T
 α_0
 CO2_0</code></pre><p>The symbolic variables and parameters can also be used to query or alter the dynamical system. For example, we can obtain, or alter, any parameter by providing the symbolic parameter index. There are multiple ways to obtain the symbolic index provided we know its name. First, we can re-create the symbolic parameter:</p><pre><code class="language-julia hljs">index = first(@parameters CO2_0)</code></pre><p class="math-container">\[ \begin{equation}
CO2_{0}
\end{equation}
 \]</p><p>Second, we can use the retrieved MTK model and access its <code>CO2_0</code> parameter:</p><pre><code class="language-julia hljs">index = mtk.CO2_0</code></pre><p class="math-container">\[ \begin{equation}
CO2_{0}
\end{equation}
 \]</p><p>Third, we can use a <code>Symbol</code> corresponding to the variable name. This is typically the simplest way.</p><pre><code class="language-julia hljs">index = :CO2_0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">:CO2_0</code></pre><p>we can query the value of this named parameter in the system,</p><pre><code class="language-julia hljs">current_parameter(ds, index)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">400.0</code></pre><p>or alter it:</p><pre><code class="language-julia hljs"># access symbolic parameter CO2_0 from the tracked symbolic list of the model
set_parameter!(ds, index, 800)</code></pre><p>Similarly, we can obtain or alter values corresponding to the dynamic variables, or observed functions of the state of the system, using their symbolic indices. For example we can obtain the value corresponding to symbolic variable <span>$T$</span> by:</p><pre><code class="language-julia hljs">observe_state(ds, T) # binding `T` already exists in scope</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">290.0</code></pre><p>or obtain the <span>$OLR$</span> (outgoing longwave radiation)</p><pre><code class="language-julia hljs">observe_state(ds, :OLR)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">245.0</code></pre><p>Let&#39;s unpack the steps that led to this level of automation.</p><h2 id="Processes"><a class="docs-heading-anchor" href="#Processes">Processes</a><a id="Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Processes" title="Permalink"></a></h2><p>A process is conceptually an <em>equation the defines a climate variable or observable</em>. All processes that composed the system are then composed into a set of differential equations via <a href="#ConceptualClimateModels.processes_to_coupledodes"><code>processes_to_coupledodes</code></a> (or <a href="#ProcessBasedModelling.processes_to_mtkmodel"><code>processes_to_mtkmodel</code></a>) that represent the climate model.</p><p>For example, the process</p><pre><code class="language-julia hljs">T_process = BasicRadiationBalance()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BasicRadiationBalance(5.0e8, f(t), T(t), ASR(t), OLR(t))</code></pre><p>is the process defining the variable <span>$T$</span>, representing temperature. We can learn this by either reading the documentation string of <a href="../processes/#ConceptualClimateModels.BasicRadiationBalance"><code>BasicRadiationBalance</code></a>, or querying it directly:</p><pre><code class="language-julia hljs">using ProcessBasedModelling: lhs, rhs
# This is the equation created by the process
lhs(T_process) ~ rhs(T_process)</code></pre><p class="math-container">\[ \begin{equation}
\frac{\mathrm{d} T\left( t \right)}{\mathrm{d}t} \tau_{T} = 0.002939 \left( \mathrm{ASR}\left( t \right) + f\left( t \right) - \mathrm{OLR}\left( t \right) \right)
\end{equation}
 \]</p><p>Notice that this process does not further define e.g. outgoing longwave radiation <code>OLR(t)</code>. That is why in the original example we also provided <a href="../processes/#ConceptualClimateModels.LinearOLR"><code>LinearOLR</code></a>, which defines it:</p><pre><code class="language-julia hljs">OLR_process = LinearOLR()
lhs(OLR_process) ~ rhs(OLR_process)</code></pre><p class="math-container">\[ \begin{equation}
\mathrm{OLR}\left( t \right) = -277 + 1.8 T\left( t \right)
\end{equation}
 \]</p><p>Each physical &quot;observable&quot; or variable that can be configured in the system has its own process. This allows very easily exchanging the way processes are represented by equations without having to alter many equations. For example, if instead of <code>LinearOLR</code> we have provided</p><pre><code class="language-julia hljs">OLR_process = EmissivityStefanBoltzmanOLR()
lhs(OLR_process) ~ rhs(OLR_process)</code></pre><p class="math-container">\[ \begin{equation}
\mathrm{OLR}\left( t \right) = 5.6704 \cdot 10^{-8} \left( T\left( t \right) \right)^{4} \varepsilon\left( t \right)
\end{equation}
 \]</p><p>then we would have used a Stefan-Boltzmann grey-atmosphere representation for the outgoing longwave radiation.</p><h2 id="Default-processes"><a class="docs-heading-anchor" href="#Default-processes">Default processes</a><a id="Default-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Default-processes" title="Permalink"></a></h2><p>Hold on a minute though, because in the original processes we provided,</p><pre><code class="language-julia hljs">processes = [
    BasicRadiationBalance(),
    LinearOLR(),
    ParameterProcess(α),
    CO2Forcing(),
]</code></pre><p>there was no process that defined the absorbed solar radiation <span>$ASR$</span>!</p><p>Well, ConceptualClimateModels.jl has a list of <a href="../processes/#predefined_processes">predefined processes</a> that are automatically included in every call to <a href="#ConceptualClimateModels.processes_to_coupledodes"><code>processes_to_coupledodes</code></a>. The default processes for the ASR is <span>$ASR = S(1-\alpha)$</span> with <span>$S$</span> the solar constant. The function <a href="#ConceptualClimateModels.processes_to_coupledodes"><code>processes_to_coupledodes</code></a> goes through all processes the user provided and identifies variables that themselves do not have a process. It then checks the list of default processes and attempt to assign one to these variables.</p><p>If there are no default processes, it makes the variables themselves parameters with the same name but with a subscript 0.</p><p>For example, let&#39;s assume that we completely remove default processes and we don&#39;t specify a process for the albedo <span>$α$</span>:</p><pre><code class="language-julia hljs">processes = [
    BasicRadiationBalance(),
    LinearOLR(),
    CO2Forcing(), # note that for default CO2 values this is zero forcing
    ASR ~ S*(1-α), # add the processes for ASR, but not for S or α
]

# note the empty list as 2nd argument, which is otherwise
# the default processes. Notice also that we make an MTK model
# (which is the step _before_ converting to a dynamical system)
mtk = processes_to_mtkmodel(processes, [])
# we access the equations directly from the model
equations(mtk)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} T\left( t \right)}{\mathrm{d}t} \tau_{T} =&amp; 0.002939 \left( \mathrm{ASR}\left( t \right) + f\left( t \right) - \mathrm{OLR}\left( t \right) \right) \\
\mathrm{OLR}\left( t \right) =&amp; -277 + 1.8 T\left( t \right) \\
f\left( t \right) =&amp; 3.7 \log_{2}\left( \frac{1}{400} \mathrm{CO2}\left( t \right) \right) \\
\mathrm{ASR}\left( t \right) =&amp; S\left( t \right) \left( 1 - \alpha\left( t \right) \right) \\
\mathrm{CO2}\left( t \right) =&amp; CO2_{0} \\
S\left( t \right) =&amp; S_{0} \\
\alpha\left( t \right) =&amp; \alpha_{0}
\end{align}
 \]</p><p>You will notice the equation <span>$α = α_0$</span> where <span>$\alpha_0$</span> is now a <em>parameter</em> of the system (i.e., it can be altered after creating the system). The value of <span>$\alpha_0$</span> is the default value of <span>$\alpha$</span>:</p><pre><code class="language-julia hljs">default_value(α)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3</code></pre><pre><code class="language-julia hljs"># current value of the _parameter_ α_0 (not the variable!)
default_value(mtk.α_0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3</code></pre><p>When this automation occurs a warning is thrown:</p><pre><code class="nohighlight hljs">┌ Warning: Variable α was introduced in process of variable ASR(t).
│ However, a process for α was not provided,
│ and there is no default process for it either.
│ Since it has a default value, we make it a parameter by adding a process:
│ `ParameterProcess(α)`.
└ @ ProcessBasedModelling ...\ProcessBasedModelling\src\make.jl:65</code></pre><p><a href="../processes/#ProcessBasedModelling.ParameterProcess"><code>ParameterProcess</code></a> is the most trivial process: it simply means that the corresponding variable does not have any physical process and rather it is a system parameter.</p><p>This automation does not occur if there is no default value. For example, variables that can never be dynamic state variables, such as <span>$ASR$</span>, do not have a default value. If we have not assigned a process for <span>$ASR$</span>, the system construction would error instead:</p><pre><code class="language-julia hljs">processes = [
    BasicRadiationBalance(),
    LinearOLR(),
    CO2Forcing(),
]

mtk = processes_to_mtkmodel(processes, [])</code></pre><pre><code class="nohighlight hljs">ERROR: ArgumentError: Variable ASR was introduced in process of
variable T(t). However, a process for ASR was not provided,
there is no default process for ASR, and ASR doesn&#39;t have a default value.
Please provide a process for variable ASR.</code></pre><p>These warnings and errors are always perfectly informative. They tell us exactly which variable does not have a process, and exactly which other process introduced the process-less variable first. This makes the modelling experience stress-free, especially when large and complex models are being created.</p><h2 id="Adding-your-own-processes"><a class="docs-heading-anchor" href="#Adding-your-own-processes">Adding your own processes</a><a id="Adding-your-own-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-your-own-processes" title="Permalink"></a></h2><p>ConceptualClimateModels.jl provides an increasing list of <a href="../processes/#predefined_processes">predefined processes</a> that you can use out of the box to compose climate models. The predefined processes all come from existing literature and cite their source via BiBTeX.</p><p>It is also very easy to make new processes on your own. The simplest way to make a process is to just provide an equation for it with the l.h.s. of the equation being the variable the process defines.</p><p>For example:</p><pre><code class="language-julia hljs">@variables x(t) = 0.5 # all variables must be functions of (t)
x_process = x ~ 0.5*T^2 # x is just a function of temperature</code></pre><p class="math-container">\[ \begin{equation}
x\left( t \right) = 0.5 \left( T\left( t \right) \right)^{2}
\end{equation}
 \]</p><p>A more re-usable approach however is to create a function that generates a process or create a new process type as we describe in <a href="#new_processes">making new processes</a>.</p><h2 id="global_vars"><a class="docs-heading-anchor" href="#global_vars">Premade symbolic variable instances</a><a id="global_vars-1"></a><a class="docs-heading-anchor-permalink" href="#global_vars" title="Permalink"></a></h2><p>You might be wondering, when we wrote the equation <code>ASR ~ S*(1-α)</code> for the <span>$ASR$</span> process, or when we wrote <code>x ~ 0.5 * T^2</code>, where did the variable bindings <code>ASR, S, α</code> come from? For convenience, ConceptualClimateModels.jl defines some symbolic variables for typical climate quantities and assigns default processes to them. we brought all of these into scope when we did</p><pre><code class="language-julia hljs">using ConceptualClimateModels.CCMV</code></pre><p>where <code>CCMV</code> (standing for ConceptualClimateModels Variables) is a submodule that defines and exports the variables. We list all of these <a href="#list_vars">below</a>. These default variables are used throughout the library as the default variables in <a href="../processes/#predefined_processes">predefined processes</a>. When going through documentation strings of <a href="../processes/#predefined_processes">predefined processes</a>, such as <a href="../processes/#ConceptualClimateModels.BasicRadiationBalance"><code>BasicRadiationBalance</code></a>, you will notice that the function call signatures are like:</p><pre><code class="language-julia hljs">BasicRadiationBalance(; T, f, kwargs...)</code></pre><p>There are keywords that do not have an assignment like <code>T, f</code> above. These always represent climate variables, never parameters, and for the variables they use the <a href="#list_vars">existing predefined climate variables</a>.</p><p>Crucially, these default variables are <em>symbolic variables</em>. They are defined as</p><pre><code class="language-julia hljs">@variables begin
    T(t) = 0.5 # ...
    # ...
end</code></pre><p>which means that expressions that involve them result in symbolic expressions,</p><pre><code class="language-julia hljs">A2 = 0.5
B2 = 0.5
OLR2 = A2 + B2*T</code></pre><p class="math-container">\[ \begin{equation}
0.5 + 0.5 T\left( t \right)
\end{equation}
 \]</p><p>In contrast, if we did instead</p><pre><code class="language-julia hljs">T2 = 0.5 # _not_ symbolic!
OLR2 = A2 + B2*T2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.75</code></pre><p>This <code>OLR2</code> is <em>not</em> a symbolic expression and <em>cannot</em> be used to represent a process.</p><p>You can use your own variables for any of the <a href="../processes/#predefined_processes">predefined processes</a> You can define them by doing</p><pre><code class="language-julia hljs">@variables begin
    (T1_tropics(t) = 290.0), [bounds = (200.0, 350.0), description = &quot;temperature in tropical box 1, in Kelvin&quot;]
end</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
\mathrm{T1}_{tropics}\left( t \right) \\
\end{array}
\right]
\end{equation}
 \]</p><p>and then assign them to the corresponding keyword argument</p><pre><code class="language-julia hljs">process = BasicRadiationBalance(T = T1_tropics)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BasicRadiationBalance(5.0e8, f(t), T1_tropics(t), ASR(t), OLR(t))</code></pre><p>Defining variables with the extra <code>bounds, description</code> annotations is useful for integrating with the rest of the functionality of the library.</p><div class="admonition is-category-warn"><header class="admonition-header">Custom variables need to be assigned everywhere!</header><div class="admonition-body"><p>Above we assigned <code>T1_tropics</code> as the temperature variable. This means we also need to assign the same variable as the one setting the <code>OLR</code> variable by also providing the processes <code>LinearOLR(T = T1_tropics)</code> (for example).</p></div></div><h3 id="list_vars"><a class="docs-heading-anchor" href="#list_vars">List of premade variables</a><a id="list_vars-1"></a><a class="docs-heading-anchor-permalink" href="#list_vars" title="Permalink"></a></h3><p>The premade variables are not exported by default. To bring them into global scope you have to do:</p><pre><code class="language-julia hljs">using ConceptualClimateModels
using ConceptualClimateModels.CCMV</code></pre><p>and then use them,</p><pre><code class="language-julia hljs">T, q, OLR</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(T(t), q(t), OLR(t))</code></pre><p>All the premade variables are:</p><pre><code class="language-julia hljs">PREDEFINED_CCM_VARIABLES</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
T\left( t \right) \\
S\left( t \right) \\
f\left( t \right) \\
\alpha\left( t \right) \\
\alpha_{ice}\left( t \right) \\
\alpha_{cloud}\left( t \right) \\
{\Delta}T\left( t \right) \\
{\Delta}S\left( t \right) \\
\varepsilon\left( t \right) \\
C\left( t \right) \\
\ell\left( t \right) \\
\mathrm{CO2}\left( t \right) \\
q\left( t \right) \\
\mathrm{OLR}\left( t \right) \\
\mathrm{ASR}\left( t \right) \\
\end{array}
\right]
\end{equation}
 \]</p><h3 id="Default-values,-limits,-etc."><a class="docs-heading-anchor" href="#Default-values,-limits,-etc.">Default values, limits, etc.</a><a id="Default-values,-limits,-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Default-values,-limits,-etc." title="Permalink"></a></h3><p>All premade variables have a default value, a description, and plausible physical bounds.</p><p>To obtain the default value, use <code>default_value(x)</code>. For the description, use <code>getdescription(x)</code>. For the bounds, use:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConceptualClimateModels.physically_plausible_limits-Tuple{Any}" href="#ConceptualClimateModels.physically_plausible_limits-Tuple{Any}"><code>ConceptualClimateModels.physically_plausible_limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">physically_plausible_limits(x)</code></pre><p>Return a tuple (min, max) of plausible limiting values for the variable <code>x</code>. If the variable does not have defined <code>bounds</code> metadata, then the default value ± 20% is used. If there is no default value, a heuristic is tried, and an error is thrown if it fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ConceptualClimateModels.jl/blob/89567ef06b3f754db804f636892f3dfba94350d2/src/statespace.jl#L2-L8">source</a></section></article><p>e.g.,</p><pre><code class="language-julia hljs">physically_plausible_limits(T)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(200.0, 350.0)</code></pre><h2 id="Automatically-named-parameters"><a class="docs-heading-anchor" href="#Automatically-named-parameters">Automatically named parameters</a><a id="Automatically-named-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Automatically-named-parameters" title="Permalink"></a></h2><p>The majority of <a href="../processes/#predefined_processes">predefined processes</a> create symbolic parameters that are automatically named based on the variables governing the processes. This default behaviour can be altered in two ways.</p><p>For example, <a href="../processes/#ConceptualClimateModels.IceAlbedoFeedback"><code>IceAlbedoFeedback</code></a> adds named parameters to the equations whose name is derived from the name of the variable representing ice albedo:</p><pre><code class="language-julia hljs">@variables my_ice_α(t) = 0.1 # don&#39;t forget the `(t)`!
ice_process = IceAlbedoFeedback(; α_ice = my_ice_α)
processes = [ice_process]

mtk = processes_to_mtkmodel(processes)
equations(mtk)</code></pre><p class="math-container">\[ \begin{align}
\mathrm{my}_{ice\_\alpha}\left( t \right) =&amp; max_{my\_ice\_\alpha} + 0.5 \left(  - max_{my\_ice\_\alpha} + min_{my\_ice\_\alpha} \right) \left( 1 + \tanh\left( \frac{2 \left(  - Tfreeze_{my\_ice\_\alpha} + \frac{1}{2} Tscale_{my\_ice\_\alpha} + T\left( t \right) \right)}{Tscale_{my\_ice\_\alpha}} \right) \right) \\
T\left( t \right) =&amp; T_{0}
\end{align}
 \]</p><pre><code class="language-julia hljs">parameters(mtk)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 max_my_ice_α
 Tfreeze_my_ice_α
 Tscale_my_ice_α
 min_my_ice_α
 T_0</code></pre><p>We can alter this behaviour by either providing our own named parameters to one of the keywords of the process, or wrapping a value around <code>LiteralParameter</code> to replace the parameter by a literal constant, like so:</p><pre><code class="language-julia hljs">@parameters myfreeze = 260.0
ice_process = IceAlbedoFeedback(;
    α_ice = my_ice_α,
    Tfreeze = myfreeze, # my custom parameter
    max = LiteralParameter(0.9) # don&#39;t make a parameter
)

mtk = processes_to_mtkmodel([ice_process])
equations(mtk)</code></pre><p class="math-container">\[ \begin{align}
\mathrm{my}_{ice\_\alpha}\left( t \right) =&amp; 0.9 + 0.5 \left( -0.9 + min_{my\_ice\_\alpha} \right) \left( 1 + \tanh\left( \frac{2 \left( \frac{1}{2} Tscale_{my\_ice\_\alpha} - myfreeze + T\left( t \right) \right)}{Tscale_{my\_ice\_\alpha}} \right) \right) \\
T\left( t \right) =&amp; T_{0}
\end{align}
 \]</p><pre><code class="language-julia hljs">parameters(mtk)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 myfreeze
 Tscale_my_ice_α
 min_my_ice_α
 T_0</code></pre><h2 id="Integration-with-DynamicalSystems.jl"><a class="docs-heading-anchor" href="#Integration-with-DynamicalSystems.jl">Integration with DynamicalSystems.jl</a><a id="Integration-with-DynamicalSystems.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-DynamicalSystems.jl" title="Permalink"></a></h2><p>ConceptualClimateModels.jl integrates with <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/dev/">DynamicalSystems.jl</a> by providing initial condition sampling to use when e.g., finding attractors and their basin fractions with <code>DynamicalSystems.basins_fractions</code>, and with the function <a href="#ConceptualClimateModels.dynamical_system_summary"><code>dynamical_system_summary</code></a>. Moreover, since all dynamical systems generated by ConceptualClimateModels.jl have symbolic bindings, one can use the symbolic variables in e.g., <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/dev/visualizations/#Interactive-or-animated-trajectory-evolution">interactive GUI exploration</a> or to access or set the parameters of the system.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConceptualClimateModels.physically_plausible_limits-Tuple{DynamicalSystem}" href="#ConceptualClimateModels.physically_plausible_limits-Tuple{DynamicalSystem}"><code>ConceptualClimateModels.physically_plausible_limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">physically_plausible_limits(ds::DynamicalSystem)</code></pre><p>Return a vector of limits (min, max) for each dynamic state variable in <code>ds</code>, assumming <code>ds</code> has been made using variables with bounds (all default symbolic variables of ConceptualClimateModels.jl satisfy this).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ConceptualClimateModels.jl/blob/89567ef06b3f754db804f636892f3dfba94350d2/src/statespace.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConceptualClimateModels.physically_plausible_ic_sampler" href="#ConceptualClimateModels.physically_plausible_ic_sampler"><code>ConceptualClimateModels.physically_plausible_ic_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">physically_plausible_ic_sampler(ds::DynamicalSystem)</code></pre><p>Return a <code>sampler</code> that can be called as a 0-argument function <code>sampler()</code>, which yields random initial conditions within the hyperrectangle defined by the <a href="#ConceptualClimateModels.physically_plausible_limits-Tuple{Any}"><code>physically_plausible_limits</code></a> of <code>ds</code>. The <code>sampler</code> is useful to give to e.g., <code>DynamicalSystems.basins_fractions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ConceptualClimateModels.jl/blob/89567ef06b3f754db804f636892f3dfba94350d2/src/statespace.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConceptualClimateModels.physically_plausible_grid" href="#ConceptualClimateModels.physically_plausible_grid"><code>ConceptualClimateModels.physically_plausible_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">physically_plausible_grid(ds::DynamicalSystem, n = 101)</code></pre><p>Return a <code>grid</code> that is a tuple of <code>range</code> objects that each spans the <a href="#ConceptualClimateModels.physically_plausible_limits-Tuple{Any}"><code>physically_plausible_limits</code></a> of <code>ds</code>. <code>n</code> can be an integer or a vector of integers (for each dimension). The resulting <code>grid</code> is useful to give to <code>DynamicalSystems.AttractorsViaRecurrences</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ConceptualClimateModels.jl/blob/89567ef06b3f754db804f636892f3dfba94350d2/src/statespace.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConceptualClimateModels.dynamical_system_summary" href="#ConceptualClimateModels.dynamical_system_summary"><code>ConceptualClimateModels.dynamical_system_summary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamical_system_summary(ds::DynamicalSystem)</code></pre><p>Return a printable/writable string containing a summary of <code>ds</code>, which outlines its current status and lists all symbolic equations and parameters that constitute the system, if a referrence to a ModelingToolkit.jl exists in <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ConceptualClimateModels.jl/blob/89567ef06b3f754db804f636892f3dfba94350d2/src/dynamicalsystems.jl#L52-L59">source</a></section></article><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConceptualClimateModels.processes_to_coupledodes" href="#ConceptualClimateModels.processes_to_coupledodes"><code>ConceptualClimateModels.processes_to_coupledodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">processes_to_coupledodes(processes, default = DEFAULT_PROCESSES; kw...)</code></pre><p>Convert a given <code>Vector</code> of processes to a <code>DynamicalSystem</code>, in particular <code>CoupledODEs</code>. All processes represent symbolic equations managed by ModelingToolkit.jl. <code>default</code> is a vector for default processes that &quot;process-less&quot; variables introduced in <code>processes</code> will obtain. Use <a href="#ProcessBasedModelling.processes_to_mtkmodel"><code>processes_to_mtkmodel</code></a> to obtain the MTK model before it is structurally simplified and converted to a <code>DynamicalSystem</code>. See also <a href="#ProcessBasedModelling.processes_to_mtkmodel"><code>processes_to_mtkmodel</code></a> for more details on what <code>processes</code> is, or see the online <a href="@ref">Tutorial</a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>diffeq</code>: options passed to DifferentialEquations.jl ODE solving when constructing the <code>CoupledODEs</code>.</li><li><code>inplace</code>: whether the dynamical system will be in place or not. Defaults to <code>true</code> if the system dimension is ≤ 5.</li><li><code>split = false</code>: whether to split parameters as per ModelingToolkit.jl. Note the default is not ModelingToolkit&#39;s default, i.e., no splitting occurs. This accelerates parameter access, assuming all parameters are of the same type.</li><li><code>kw...</code>: all other keywords are propagated to <code>processes_to_mtkmodel</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ConceptualClimateModels.jl/blob/89567ef06b3f754db804f636892f3dfba94350d2/src/dynamicalsystems.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProcessBasedModelling.processes_to_mtkmodel" href="#ProcessBasedModelling.processes_to_mtkmodel"><code>ProcessBasedModelling.processes_to_mtkmodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">processes_to_mtkmodel(processes::Vector, default::Vector = []; kw...)</code></pre><p>Construct a ModelingToolkit.jl model/system using the provided <code>processes</code> and <code>default</code> processes. The model/system is <em>not</em> structurally simplified.</p><p><code>processes</code> is a vector whose elements can be:</p><ul><li>Any instance of a subtype of <a href="#ProcessBasedModelling.Process"><code>Process</code></a>.</li><li>An <code>Equation</code> which is of the form <code>variable ~ expression</code> with <code>variable</code> a single variable resulting from an <code>@variables</code> call.</li><li>A vector of the above two, which is then expanded. This allows the convenience of functions representing a physical process that may require many equations to be defined.</li></ul><p><code>default</code> is a vector that can contain the first two possibilities only as it contains default processes that may be assigned to variables introduced in <code>processes</code> but they don&#39;t themselves have an assigned process.</p><p>It is expected that downstream packages that use ProcessBasedModelling.jl to make a field-specific library implement a 1-argument version of <code>processes_to_mtkmodel</code>, or provide a wrapper function for it, and add a default value for <code>default</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>type = ODESystem</code>: the model type to make</li><li><code>name = nameof(type)</code>: the name of the model</li><li><code>independent = t</code>: the independent variable (default: <code>@variables t</code>). <code>t</code> is also exported by ProcessBasedModelling.jl for convenience.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ProcessBasedModelling.jl/blob/v1.0.1/src/make.jl#L1-L29">source</a></section></article><h3 id="new_processes"><a class="docs-heading-anchor" href="#new_processes">Making new processes</a><a id="new_processes-1"></a><a class="docs-heading-anchor-permalink" href="#new_processes" title="Permalink"></a></h3><p>To make a new processes you can:</p><ol><li>Create a <em>function</em> that given some keyword arguments (including which symbolic variables to use) uses one of the existing <a href="../processes/#generic_processes">generic processes</a> to make and return a process instance. Or, it can return an equation directly, provided it satisfies the format of <a href="#ProcessBasedModelling.processes_to_mtkmodel"><code>processes_to_mtkmodel</code></a>. For an example of this, see the source code of <a href="../processes/#ConceptualClimateModels.SeparatedClearAllSkyAlbedo"><code>SeparatedClearAllSkyAlbedo</code></a> or <a href="../processes/#ConceptualClimateModels.EmissivityFeedbackTanh"><code>EmissivityFeedbackTanh</code></a>.</li><li>Create a new <code>Process</code> subtype. This is preferred, because it leads to much better printing/display of the list of processes. For an example of this, see the source code of <a href="../processes/#ConceptualClimateModels.IceAlbedoFeedback"><code>IceAlbedoFeedback</code></a>. To create a new <code>Process</code> see the <a href="https://juliadynamics.github.io/ProcessBasedModelling.jl/stable/#Process-API">API of ProcessBasedModelling.jl</a> or read the documentation string of <a href="#ProcessBasedModelling.Process"><code>Process</code></a> below.</li></ol><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ProcessBasedModelling.Process" href="#ProcessBasedModelling.Process"><code>ProcessBasedModelling.Process</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Process</code></pre><p>A new process must subtype <code>Process</code> and can be used in <a href="#ProcessBasedModelling.processes_to_mtkmodel"><code>processes_to_mtkmodel</code></a>. The type must extend the following functions from the module <code>ProcessBasedModelling</code>:</p><ul><li><code>lhs_variable(p)</code> which returns the variable the process describes (left-hand-side variable). There is a default implementation <code>lhs_variable(p) = p.variable</code> if the field exists.</li><li><code>rhs(p)</code> which is the right-hand-side expression, i.e., the &quot;actual&quot; process.</li><li>(optional) <code>timescale(p)</code>, which defaults to <a href="@ref"><code>NoTimeDerivative</code></a>.</li><li>(optional) <code>lhs(p)</code> which returns the left-hand-side. Let <code>τ = timescale(p)</code>. Then default <code>lhs(p)</code> behaviour depends on <code>τ</code> as follows:<ul><li>Just <code>lhs_variable(p)</code> if <code>τ == NoTimeDerivative()</code>.</li><li><code>Differential(t)(p)</code> if <code>τ == nothing</code>.</li><li><code>τ_var*Differential(t)(p)</code> if <code>τ isa Union{Real, Num}</code>. If real, a new named parameter <code>τ_var</code> is created that has the prefix <code>:τ_</code> and then the lhs-variable name and has default value <code>τ</code>. Else if <code>Num</code>, <code>τ_var = τ</code> as given.</li><li>Explicitly extend <code>lhs_variable</code> if the above do not suit you.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ProcessBasedModelling.jl/blob/v1.0.1/src/API.jl#L1-L20">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../processes/">Predefined processes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 13 March 2024 10:14">Wednesday 13 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
